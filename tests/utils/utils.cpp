#include "utils.h"

using namespace tests;

QString utils::getCppText()
{
    return "#include <QTimer>\n"
           "#include <QFontMetricsF>\n"
           "#include <QPaintEvent>\n"
           "#include <QPainter>\n"
           "#include <QDebug>\n"
           "\n"
           "// Start of a folding range\n"
           "// folding range 1\n"
           "// folding range 2\n"
           "// folding range 3\n"
           "// End of a folding range\n"
           "// Next to the end of a folding range\n"
           "\n"
           "using namespace vte;\n"
           "\n"
           "// START Here is a long long comment which is used to test word wrap within a block very long long long IndicatorsBorder::IndicatorsBorder(IndicatorsBorderInterface *p_interface word word word word wrap wrap here is the end of this long line END\n"
           "IndicatorsBorder::IndicatorsBorder(IndicatorsBorderInterface *p_interface,\n"
           "                                   IndicatorsBorder::LineNumberType p_lineNumberType,\n"
           "                                   QWidget *p_parent)\n"
           "    : QWidget(p_parent),\n"
           "      m_interface(p_interface),\n"
           "      m_lineNumberType(p_lineNumberType)\n"
           "{\n"
           "    setAttribute(Qt::WA_StaticContents);\n"
           "    setAttribute(Qt::WA_OpaquePaintEvent);\n"
           "\n"
           "    setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Minimum);\n"
           "\n"
           "    setFont(font());\n"
           "}\n"
           "\n"
           "IndicatorsBorder::LineNumberType IndicatorsBorder::getLineNumberType() const\n"
           "{\n"
           "    return m_lineNumberType;\n"
           "}\n"
           "\n"
           "void IndicatorsBorder::setLineNumberType(IndicatorsBorder::LineNumberType p_type)\n"
           "{\n"
           "    if (p_type == m_lineNumberType) {\n"
           "        return;\n"
           "    }\n"
           "\n"
           "    m_lineNumberType = p_type;\n"
           "}\n"
           "\n"
           "QSize IndicatorsBorder::sizeHint() const\n"
           "{\n"
           "    int w = 1;\n"
           "    if (!m_indicatorsPosition.isEmpty()) {\n"
           "        w = m_indicatorsPosition.last().first;\n"
           "    }\n"
           "\n"
           "    return QSize(w, 0);\n"
           "}\n"
           "\n"
           "void IndicatorsBorder::setFont(const QFont &p_font)\n"
           "{\n"
           "    m_font = p_font;\n"
           "\n"
           "    const QFontMetricsF fm(m_font);\n"
           "    m_maxCharWidth = 0.0;\n"
           "    // Loop to determine the widest numeric character in the current font.\n"
           "    // 48 is ascii '0'.\n"
           "    for (int i = 48; i < 58; i++) {\n"
           "        const qreal charWidth = ceil(fm.horizontalAdvance(QChar(i)));\n"
           "        m_maxCharWidth = qMax(m_maxCharWidth, charWidth);\n"
           "    }\n"
           "\n"
           "    m_needUpdateIndicatorsPosition = true;\n"
           "\n"
           "    requestUpdate();\n"
           "}\n"
           "\n"
           "void IndicatorsBorder::requestUpdate()\n"
           "{\n"
           "    QTimer::singleShot(0, this, SLOT(update()));\n"
           "}\n"
           "\n"
           "int IndicatorsBorder::lineNumberWidth()\n"
           "{\n"
           "    if (m_lineNumberType == LineNumberType::None) {\n"
           "        m_lineNumberCount = 0;\n"
           "        return 0;\n"
           "    }\n"
           "\n"
           "    int blockCount = m_interface->getBlockCount();\n"
           "    if (blockCount == m_lineNumberCount) {\n"
           "        return m_lineNumberWidth;\n"
           "    }\n"
           "\n"
           "    m_lineNumberCount = blockCount;\n"
           "    const int digits = (int)ceil(log10((double)(m_lineNumberCount + 1)));\n"
           "    m_lineNumberWidth = (int)ceil((digits + 1) * m_maxCharWidth);\n"
           "    return m_lineNumberWidth;\n"
           "}\n"
           "\n"
           "void IndicatorsBorder::paintEvent(QPaintEvent *p_event)\n"
           "{\n"
           "    paintBorder(p_event->rect());\n"
           "}\n"
           "\n"
           "void IndicatorsBorder::paintBorder(const QRect &p_rect)\n"
           "{\n"
           "    const int y = p_rect.y();\n"
           "    const int height = p_rect.height();\n"
           "    qDebug() << \"paintBorder\" << p_rect;\n"
           "\n"
           "    QPainter painter(this);\n"
           "    painter.setRenderHints(QPainter::TextAntialiasing);\n"
           "    painter.setFont(m_font);\n"
           "\n"
           "    // Paint background.\n"
           "    painter.fillRect(p_rect, m_backgroundColor);\n"
           "\n"
           "    // Paint the borader in chunks line by line.\n"
           "}\n";
}
